import Ember from 'ember';


/**
 * The test records what you do and records the changes in the app.
 * You should only add this component to your app when your app behaves as
 * expected as the mutations will be recorded.
 *
 * The point of this is that if you record mutations in a page behaving as expected
 * this should make for useful tests as you continue development.
 *
 *
 * Usage
 *
 * The component requires information from the applicationController and should be placed
 * inside the application.hbs template
 *
 * ```hbs
 * {{test-recorder currentRouteName=currentRouteName}}
 * ```
 * If you want a particular node to be tested for being in the active dom then give it an id
 * eg an element of `<p></p>` will not be tested, but `<p id='foo'></p>` will have a test generated like:
 * ```js
 *
 * ```
 *
 * TIPS
 *
 * Avoid making muliple button clicks (or other interactions that cause asychronus)
 * updates until DOM has finished updating. This
 * will allow code generated by the mutations observer to be placed in the in the
 * generated code.
 *
 * There are currently some hacks as this is designed not to be embedded into your application,
 * ie require code modification.
 *
 */

export default Ember.Component.extend({
  MUTATIONS_PLACEHOLDER: "[MUTATIONS_PLACEHOLDER]", //holds text to be added from mutations

  generatedScript: "",//holds the script to be rendered in <pre> tags for copying as source
  renderedScript: "",//holds the actual rendered script

  // holds the script generated by the mutation observers, because
  // want this test recorder to sit outside the ember app and not be intrusive
  pendingGeneratedDomChangedScript: "",

  currentRouteName: "",
  routeHasChanged: false, //if true render a test condition for this
  onCurrentRouteNameChange: function () {
    //console.log(this.get("currentRouteName"));

    /* //todo alternative?
     window.onhashchange = function locationHashChanged() {
     };
     window.addEventListener('popstate', function locationHashChanged(e) {
     });
     * */
    //todo have a timing mechanism or wait for all promises are fulfilled
    this.set("routeHasChanged", true);
  }.observes("currentRouteName"),

  onRenderedScriptChange: function () {
    $("#renderedScript").html(this.get("renderedScript"));
  }.observes("renderedScript"),

  /**
   * Initialize Test recorder
   * @return {undefined}
   */
  didInsertElement: function () {

    var emberSelector = '[id^=ember],[data-ember-action]';
    var self = this;
    var indendation = '  ';//2 spaces

    Ember.$.fn.extend({
      path: function () {

        if (this.length !== 1) {
          throw 'Requires one element.';
        }

        var path, node = this;
        while (node.length) {
          var realNode = node[0], name = realNode.localName;
          if (!name) {
            break;
          }
          name = name.toLowerCase();

          var parent = node.parent();

          var siblings = parent.children(name);
          if (siblings.length > 1) {
            name += ':eq(' + siblings.index(realNode) + ')';
          }

          path = name + (path ? '>' + path : '');
          node = parent;
        }

        return path;
      }
    });
    Ember.run(function () {
      Ember.$(document).on('click', function (e) {

        //clear this if not DOM mutations happen ()
        var cleanText = self.get("generatedScript").replace(self.get("MUTATIONS_PLACEHOLDER"), "");
        self.set("generatedScript", cleanText);

        var $target = $(e.target);
        var $emberTarget = $target.is(emberSelector) ? $target : $target.parent(emberSelector);

        if ($emberTarget.length) {
          var pathPrint = e.target.id ? "#" + e.target.id : $emberTarget.path();
          var newTestPrint = 'click("' + pathPrint + '");<br/>' + 'andThen(function () {' + '<br/>';

          //TEST 1 - > Assert the route is what it a changed to
          // todo hook this to afterModel in the final route
          if (self.get("routeHasChanged")) {
            newTestPrint += indendation + 'equal(currentRouteName(), "' +
            self.get("currentRouteName") +
            '", "The page navigates to ' + self.get("currentRouteName") +
            ' on button click");<br/>'; //todo make reason more dynamic
            self.set("routeHasChanged", false);
          }

          //TEST 2 - > Place holder that will be replaced with dom visibility Assertions
          // the last one of these is replaced each time the mutation observes are run
          newTestPrint += self.get("MUTATIONS_PLACEHOLDER") + '<br/>' +

            //Close the and then block
          '});<br/><br/>'
          // console.log(testLinePrint);

          //add to exisiting tests
          self.set("generatedScript", self.get("generatedScript") + newTestPrint);

          //todo hack to fill in mutations
          var withReplacement = self.get("generatedScript").replace(self.get("MUTATIONS_PLACEHOLDER"), self.get("pendingGeneratedDomChangedScript"));
          self.set("generatedScript", withReplacement);

          //wrap in <pre> block to make code well formatted
          self.set("renderedScript", '<pre>' + self.get("generatedScript") + '</pre>');


        }

      });
    })
    //only observe inside the ember app, get 1st ember div todo possibly move this outside
    var target = document.querySelector('body [id^=ember]');

    var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;

    //todo, fix this hack -> this will fire before the onClick of jquery so we chache the genrated text here for now
    var observer = new MutationObserver(function (mutations) {

      var addedNodesTestText = "";
      var removedNodesTestText = "";

      mutations.forEach(function (mutation) {

        //convert these to Arrays
        var addedNodesArray = Array.prototype.slice.call(mutation.addedNodes);
        var removedNodesArray = Array.prototype.slice.call(mutation.removedNodes);

        //ignore non tagged markup like carriage returns //todo investigate why ember does this, potential reflow issue
        addedNodesArray = addedNodesArray.filter(function (node) {
          return node.nodeType !== 3 && node.id;
        });
        removedNodesArray = removedNodesArray.filter(function (node) {
          return node.nodeType !== 3 && node.id;
        });

        //mutations should be mutually exclusive?
        if (addedNodesArray.length && removedNodesArray.length) {
          alert("strange");
          return;
        }

        addedNodesArray.forEach(function (node) {
          addedNodesTestText += indendation + 'equal(find("' + node.id + '").length, 1, "' + node.id + ' shown AFTER user <INSERT REASON>");';
        });

        removedNodesArray.forEach(function (node) {
          removedNodesTestText += indendation + 'equal(find("' + node.id + '").length, 1, "' + node.id + ' removed AFTER user <INSERT REASON>");';
        });

        var currentText = self.get("generatedScript");
        self.set("pendingGeneratedDomChangedScript", addedNodesTestText || removedNodesTestText);
        // self.set("generatedScript", newText);
        console.log(mutation);
      });
    });
    var config = {attributes: true, childList: true, characterData: true};

    observer.observe(target, config);
    //observer.disconnect();

    //var rect = obj.getBoundingClientRect();
  }
});

