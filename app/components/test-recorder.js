import Ember from 'ember';

export default Ember.Component.extend({
  classNames: ['dont'], //this is the output code, we don't want to generate any code form changes in this

  MUTATIONS_PLACEHOLDER: "[MUTATIONS_PLACEHOLDER]", //holds text to be added from mutations

  generatedScript: "",//holds the script to be rendered in <pre> tags for copying as source
  renderedScript: "",//holds the actual rendered script

  // holds the script generated by the mutation observers, because
  // want this test recorder to sit outside the ember app and not be intrusive
  pendingGeneratedDomChangedScript: "",

  currentRouteName: "",
  routeHasChanged: false, //if true render a test condition for this

  mutationObserversArr: [], // we disconnect these when the component is removed form the canvas (essential for testing)

  willDestroyElement: function () {
    console.log("destroying " + this.get("mutationObserversArr").length + " mut observers ");
    this.get("mutationObserversArr").forEach(function (observer) {
      observer.disconnect();
    });
  },

  /**
   * selects all the generated source code when user clicks on the UI for the code
   * @param el
   */
  click: function (el) {
    var range;
    if (window.getSelection && document.createRange) {
      range = document.createRange();
      var sel = window.getSelection();
      range.selectNodeContents(el.currentTarget);
      sel.removeAllRanges();
      sel.addRange(range);
    } else if (document.body && document.body.createTextRange) {
      range = document.body.createTextRange();
      range.moveToElementText(el);
      range.select();
    }
  },

  actions: {
    copyToClipBoard: function () {
      //todo
    }
  },

  onCurrentRouteNameChange: Ember.observer('currentRouteName', function () {
    console.log(this.get("currentRouteName"));
    this.set("routeHasChanged", true);
  }),

  onRenderedScriptChange: Ember.observer('renderedScript', function () {
    $("#renderedScript").html(this.get("renderedScript"));
  }),

  /**
   * Initialize Test recorder
   * @return {undefined}
   */
  didInsertElement: function () {

    var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;

    //listen to clicks on ember items, apart from
    //the test recorder UI (the dont class)
    var emberSelector = '[id^=ember]:not(.dont),[data-ember-action]';
    var self = this;
    var indentation = ' ';//2 spaces
    var currentNestedLevel = 0; //tracks the nesting level for mutations

    /**
     * This is a helper function extension of jquery to give us a dynamic path incase the user hasn't given an
     * interactive element an ID. We then use  this path to repeat the user action in a test case.
     */
    Ember.$.fn.extend({
      path: function () {

        if (this.length !== 1) {
          throw 'Requires one element.';
        }

        var path, node = this;
        //this is just to get the path if the user interacts with a non user given id object
        //we stop at body as qunit tests  find statement is relative to the #ember-testing div
        while (node.length && node[0].localName !== 'body') {
          var realNode = node[0], name = realNode.localName;
          if (!name) {
            break;
          }
          name = name.toLowerCase();

          var parent = node.parent();

          var siblings = parent.children(name);
          if (siblings.length > 1) {
            name += ':eq(' + siblings.index(realNode) + ')';
          }

          path = name + (path ? '>' + path : '');
          node = parent;
        }

        return path;
      }
    });
    Ember.$(document).on('click', function (e) {

      //clear this if not DOM mutations happen ()
      var cleanText = self.get("generatedScript").replace(self.get("MUTATIONS_PLACEHOLDER"), "");
      self.set("generatedScript", cleanText);

      var $target = $(e.target);
      var $emberTarget = $target.is(emberSelector) ? $target : $target.parent(emberSelector);

      if ($emberTarget.length) {
        // we don't want to output a click (#ember123) as this is not reliable
        var hasEmberIdRegex = /ember[\d]+/;
        if (e.target.id && !hasEmberIdRegex.test(e.target.id)) {
          var pathPrint = "#" + e.target.id;
        } else {
          //print the nasty DOM path instead, to avoid give your element its own id
          var pathPrint = $emberTarget.path();
        }


        var newTestPrint = 'click("' + pathPrint + '");<br/>' + 'andThen(function () {' + '<br/>';

        //TEST 1 - > Assert the route is what it a changed to
        if (self.get("routeHasChanged")) {
          newTestPrint += indentation + 'assert.equal(currentRouteName(), "' +
            self.get("currentRouteName") +
            '", "The page navigates to ' + self.get("currentRouteName") +
            ' on button click");<br/>'; //todo make reason more dynamic
          self.set("routeHasChanged", false);
        }

        //TEST 2 - > Place holder that will be replaced with dom visibility Assertions
        // the last one of these is replaced each time the mutation observes are run
        newTestPrint += self.get("MUTATIONS_PLACEHOLDER") + '<br/>' +
            //Close the and then block
          '});<br/><br/>'
        // console.log(testLinePrint);

        //add to exisiting tests
        self.set("generatedScript", self.get("generatedScript") + newTestPrint);

        var withReplacement = self.get("generatedScript").replace(self.get("MUTATIONS_PLACEHOLDER"), self.get("pendingGeneratedDomChangedScript"));
        self.set("generatedScript", withReplacement);
        self.set("pendingGeneratedDomChangedScript", "") //clear

        //wrap in <pre> block to make code well formatted
        self.set("renderedScript", '<pre>' + self.get("generatedScript") + '</pre>');
      }

    });

    /**
     * Adds observer for target and generates source code
     * @param target
     */
    function addObserverForTarget(target) {

      var observer = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {

          var addedNodesTestText = "";
          var removedNodesTestText = "";

          //convert these to Arrays
          var addedNodesArray = Array.prototype.slice.call(mutation.addedNodes);
          var removedNodesArray = Array.prototype.slice.call(mutation.removedNodes);

          // This array is used to add new mutation Observers from the newly added DOM
          var newMutationsFromAddedNodesArray = addedNodesArray.filter(filterDoNotRecordAndWhiteSpace);

          //loop through the above and add observers, we need to do this dynamically
          newMutationsFromAddedNodesArray.forEach(function (node) {
            addObserverForTarget(node); //just drill down 2 levels more
          })

          //this array is used to generate the source code, we filter
          addedNodesArray = addedNodesArray.filter(filter_DoNotRecord_WhiteSpace_emberID_noID);
          removedNodesArray = removedNodesArray.filter(filter_DoNotRecord_WhiteSpace_emberID_noID);

          if (!addedNodesArray.length && !removedNodesArray.length) {
            //no point continuing in this iteration if nothing of interest
            return;
          }

          //mutations should be mutually exclusive?
          if (addedNodesArray.length && removedNodesArray.length) {
            alert("strange");
            return;
          }

          addedNodesArray.forEach(function (node) {
            addedNodesTestText += indentation + 'assert.equal(find("#' + node.id + '").length, 1, "' + node.id + ' shown AFTER user [INSERT REASON]");' + '<br/>';
          });

          removedNodesArray.forEach(function (node) {
            removedNodesTestText += indentation + 'assert.equal(find("#' + node.id + '").length, 0, "' + node.id + ' removed AFTER user [INSERT REASON]");' + '<br/>';
          });

          self.set("pendingGeneratedDomChangedScript", self.get("pendingGeneratedDomChangedScript") + (addedNodesTestText || removedNodesTestText));
          // self.set("generatedScript", newText);
          console.log(mutation);
        });
      });
      var config = {attributes: true, childList: true, characterData: true};

      //this is the only place where observe is called so we can track them here too to disconnect
      observer.observe(target, config);
      self.get("mutationObserversArr").push(observer);
      addInnerObserversForTarget(target, 0);//forms new observers recursively


    }

    /**
     * Create observers for the children
     * Can be used recursively to desired depth, atm this is set to max of 4
     * @param target
     */
    function addInnerObserversForTarget(target, currentLevel) {
      for (var i = 0; target.children && i < target.children.length; i++) {
        var child = target.children[i];
        var classListArray = child.classList && Array.prototype.slice.call(child.classList);
        var hasDoNotRecordClass = classListArray ? (classListArray.indexOf("doNotRecord") !== -1) : false;

        if (!hasDoNotRecordClass) {//abort any recording of this dom tree
          addObserverForTarget(child);
          if (currentLevel <= 6) {//todo compare with root ember element
            var nextLevel = currentLevel + 1;
            addInnerObserversForTarget(child, nextLevel)
          }
        }
      }
    }

    //todo possibly move this outside if users wish to look outside ember app
    var target = document.querySelector('body [id^=ember]');
    addObserverForTarget(target);//as this does't do the recursive listeners straight away we have to call this:

  }
});

function filter_DoNotRecord_WhiteSpace_emberID_noID(node) {
  var classListArray = node.classList && Array.prototype.slice.call(node.classList);
  //var isEmberView = classListArray ? (classListArray.indexOf("ember-view") === -1) : false;
  var hasDoNotRecordClass = classListArray ? (classListArray.indexOf("doNotRecord") !== -1) : false;

  //the check here is we don't want to record
  // 1 whitespace
  // 2 things with no id
  // 3 things that have a hasDoNotRecordClass
  // 4 things with an ember id, (where a user has not given one but ember needs to add an id)
  var hasEmberIdRegex = /ember[\d]+/;

  return node.nodeType !== 3 && node.id && !hasDoNotRecordClass && !hasEmberIdRegex.test(node.id);
}

function filterDoNotRecordAndWhiteSpace(node) {
  var classListArray = node.classList && Array.prototype.slice.call(node.classList);
  //var isEmberView = classListArray ? (classListArray.indexOf("ember-view") === -1) : false;
  var hasDoNotRecordClass = classListArray ? (classListArray.indexOf("doNotRecord") !== -1) : false;
  return node.nodeType !== 3 && !hasDoNotRecordClass;
}
