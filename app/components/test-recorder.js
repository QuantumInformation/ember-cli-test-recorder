import Ember from 'ember';




export default Ember.Component.extend({
  MUTATIONS_PLACEHOLDER: "[MUTATIONS_PLACEHOLDER]", //holds text to be added from mutations

  generatedScript: "",//holds the script to be rendered in <pre> tags for copying as source
  renderedScript: "",//holds the actual rendered script

  // holds the script generated by the mutation observers, because
  // want this test recorder to sit outside the ember app and not be intrusive
  pendingGeneratedDomChangedScript: "",

  currentRouteName: "",
  routeHasChanged: false, //if true render a test condition for this

  click: function (el) {
    var range;
    if (window.getSelection && document.createRange) {
      range = document.createRange();
      var sel = window.getSelection();
      range.selectNodeContents(el.currentTarget);
      sel.removeAllRanges();
      sel.addRange(range);
    } else if (document.body && document.body.createTextRange) {
      range = document.body.createTextRange();
      range.moveToElementText(el);
      range.select();
    }
  },

  actions: {
    copyToClipBoard: function () {
      //todo
    }
  },

  onCurrentRouteNameChange: function () {
    //console.log(this.get("currentRouteName"));

    /* //todo alternative?
     window.onhashchange = function locationHashChanged() {
     };
     window.addEventListener('popstate', function locationHashChanged(e) {
     });
     * */
    //todo have a timing mechanism or wait for all promises are fulfilled
    this.set("routeHasChanged", true);
  }.observes("currentRouteName"),

  onRenderedScriptChange: function () {
    $("#renderedScript").html(this.get("renderedScript"));
  }.observes("renderedScript"),

  /**
   * Initialize Test recorder
   * @return {undefined}
   */
  didInsertElement: function () {

    var emberSelector = '[id^=ember],[data-ember-action]';
    var self = this;
    var indendation = '  ';//2 spaces

    Ember.$.fn.extend({
      path: function () {

        if (this.length !== 1) {
          throw 'Requires one element.';
        }

        var path, node = this;
        while (node.length) {
          var realNode = node[0], name = realNode.localName;
          if (!name) {
            break;
          }
          name = name.toLowerCase();

          var parent = node.parent();

          var siblings = parent.children(name);
          if (siblings.length > 1) {
            name += ':eq(' + siblings.index(realNode) + ')';
          }

          path = name + (path ? '>' + path : '');
          node = parent;
        }

        return path;
      }
    });
    Ember.run(function () {
      Ember.$(document).on('click', function (e) {

        //clear this if not DOM mutations happen ()
        var cleanText = self.get("generatedScript").replace(self.get("MUTATIONS_PLACEHOLDER"), "");
        self.set("generatedScript", cleanText);

        var $target = $(e.target);
        var $emberTarget = $target.is(emberSelector) ? $target : $target.parent(emberSelector);

        if ($emberTarget.length) {
          var pathPrint = e.target.id ? "#" + e.target.id : $emberTarget.path();
          var newTestPrint = 'click("' + pathPrint + '");<br/>' + 'andThen(function () {' + '<br/>';

          //TEST 1 - > Assert the route is what it a changed to
          // todo hook this to afterModel in the final route
          if (self.get("routeHasChanged")) {
            newTestPrint += indendation + 'equal(currentRouteName(), "' +
            self.get("currentRouteName") +
            '", "The page navigates to ' + self.get("currentRouteName") +
            ' on button click");<br/>'; //todo make reason more dynamic
            self.set("routeHasChanged", false);
          }

          //TEST 2 - > Place holder that will be replaced with dom visibility Assertions
          // the last one of these is replaced each time the mutation observes are run
          newTestPrint += self.get("MUTATIONS_PLACEHOLDER") + '<br/>' +

            //Close the and then block
          '});<br/><br/>'
          // console.log(testLinePrint);

          //add to exisiting tests
          self.set("generatedScript", self.get("generatedScript") + newTestPrint);

          //todo hack to fill in mutations
          var withReplacement = self.get("generatedScript").replace(self.get("MUTATIONS_PLACEHOLDER"), self.get("pendingGeneratedDomChangedScript"));
          self.set("generatedScript", withReplacement);
          self.set("pendingGeneratedDomChangedScript", "") //clear

          //wrap in <pre> block to make code well formatted
          self.set("renderedScript", '<pre>' + self.get("generatedScript") + '</pre>');


        }

      });
    })
    //only observe inside the ember app, get 1st ember div todo possibly move this outside
    var target = document.querySelector('body [id^=ember]');

    var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;

    //todo, fix this hack -> this will fire before the onClick of jquery so we chache the genrated text here for now
    var observer = new MutationObserver(function (mutations) {



      ///todo this is a hack to stop multipl hits for mutations with the same id (has to do with childlists)
      var alreadyRemoved = [];

      mutations.forEach(function (mutation) {

        var addedNodesTestText = "";
        var removedNodesTestText = "";

        //convert these to Arrays
        var addedNodesArray = Array.prototype.slice.call(mutation.addedNodes);
        var removedNodesArray = Array.prototype.slice.call(mutation.removedNodes);

        //ignore non tagged markup like carriage returns //todo investigate why ember does this, potential reflow issue
        addedNodesArray = addedNodesArray.filter(function (node) {
          return node.nodeType !== 3 && node.id;
        });
        removedNodesArray = removedNodesArray.filter(function (node) {
          return node.nodeType !== 3 && node.id;
        });

        if (!addedNodesArray.length && !removedNodesArray.length) {
          //no point continuing in this iteration if nothing of interest
          return;
        }

        //mutations should be mutually exclusive?
        if (addedNodesArray.length && removedNodesArray.length) {
          alert("strange");
          return;
        }

        addedNodesArray.forEach(function (node) {
          addedNodesTestText += indendation + 'equal(find("#' + node.id + '").length, 1, "' + node.id + ' shown AFTER user [INSERT REASON]");' + '<br/>';
        });

        removedNodesArray.forEach(function (node) {
          removedNodesTestText += indendation + 'equal(find("#' + node.id + '").length, 0, "' + node.id + ' removed AFTER user [INSERT REASON]");' + '<br/>';
        });

        self.set("pendingGeneratedDomChangedScript", self.get("pendingGeneratedDomChangedScript") + (addedNodesTestText || removedNodesTestText));
        // self.set("generatedScript", newText);
        console.log(mutation);
      });
    });
    var config = {attributes: true, childList: true, characterData: true};

    observer.observe(target, config);
    //observer.disconnect();

    //var rect = obj.getBoundingClientRect();
  }
});

